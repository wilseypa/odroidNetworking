From 0284eb59cb811d2b743991be427474ad440a4293 Mon Sep 17 00:00:00 2001
From: Eli Cohen <eli@mellanox.co.il>
Date: Tue, 9 Feb 2010 17:53:26 +0200
Subject: [PATCH 10/12] ib_core: Add VLAN support to IBoE

Add 802.1q vlan support to IBoE. The vlan tag is encoded within the GID
derived from a link local address in the following way:

GID[11] GID[12] contain the vlan ID.
The 3 bit user priority field is identical to the 3 bits of the SL.

In case rdma_cm apps, the TOS field is used to generate the SL field by doing a
shift right of 5 bits effectively taking to 3 MS bits of the TOS field. In
order to support userspace verbs consumers, ib_uverbs_get_mac has changed into
ib_uverbs_get_eth_l2_addr and now returns both MAC and VLAN information.

Signed-off-by: Eli Cohen <eli@mellanox.co.il>
---
 drivers/infiniband/core/cma.c        |   20 ++++++++++++--------
 drivers/infiniband/core/ucma.c       |   13 +++++++++++--
 drivers/infiniband/core/ud_header.c  |   31 +++++++++++++++++++++++++++++--
 drivers/infiniband/core/uverbs_cmd.c |    2 +-
 drivers/infiniband/core/verbs.c      |    4 ++--
 include/rdma/ib_addr.h               |   24 ++++++++++++++++++++----
 include/rdma/ib_pack.h               |   19 +++++++++----------
 include/rdma/ib_user_verbs.h         |    3 ++-
 include/rdma/ib_verbs.h              |    6 ++++--
 9 files changed, 90 insertions(+), 32 deletions(-)

Index: ofa_kernel-1.5.1/drivers/infiniband/core/cma.c
===================================================================
--- ofa_kernel-1.5.1.orig/drivers/infiniband/core/cma.c
+++ ofa_kernel-1.5.1/drivers/infiniband/core/cma.c
@@ -1784,6 +1784,7 @@ static int cma_resolve_iboe_route(struct
 	struct sockaddr_in *src_addr = (struct sockaddr_in *)&route->addr.src_addr;
 	struct sockaddr_in *dst_addr = (struct sockaddr_in *)&route->addr.dst_addr;
 	struct net_device *ndev = NULL;
+	u16 vid = 0;
 
 	if (src_addr->sin_family != dst_addr->sin_family)
 		return -EINVAL;
@@ -1803,14 +1804,6 @@ static int cma_resolve_iboe_route(struct
 
 	route->num_paths = 1;
 
-	iboe_mac_to_ll(&route->path_rec->sgid, addr->dev_addr.src_dev_addr);
-	iboe_mac_to_ll(&route->path_rec->dgid, addr->dev_addr.dst_dev_addr);
-
-	route->path_rec->hop_limit = 1;
-	route->path_rec->reversible = 1;
-	route->path_rec->pkey = cpu_to_be16(0xffff);
-	route->path_rec->mtu_selector = IB_SA_EQ;
-
 	if (addr->dev_addr.bound_dev_if)
 		ndev = dev_get_by_index(&init_net, addr->dev_addr.bound_dev_if);
 	if (!ndev) {
@@ -1818,11 +1811,24 @@ static int cma_resolve_iboe_route(struct
 		goto err2;
 	}
 
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	vid = vlan_dev_vlan_id(ndev);
+#endif
+
+	iboe_mac_vlan_to_ll(&route->path_rec->sgid, addr->dev_addr.src_dev_addr, vid);
+	iboe_mac_vlan_to_ll(&route->path_rec->dgid, addr->dev_addr.dst_dev_addr, vid);
+
+	route->path_rec->hop_limit = 1;
+	route->path_rec->reversible = 1;
+	route->path_rec->pkey = cpu_to_be16(0xffff);
+	route->path_rec->mtu_selector = IB_SA_EQ;
+	route->path_rec->sl = id_priv->tos >> 5;
+
 	route->path_rec->mtu = iboe_get_mtu(ndev->mtu);
-	route->path_rec->rate_selector = 2;
+	route->path_rec->rate_selector = IB_SA_EQ;
 	route->path_rec->rate = iboe_get_rate(ndev);
 	dev_put(ndev);
-	route->path_rec->packet_life_time_selector = 2;
+	route->path_rec->packet_life_time_selector = IB_SA_EQ;
 	route->path_rec->packet_life_time = IBOE_PACKET_LIFETIME;
 	if (!route->path_rec->mtu) {
 		ret = -EINVAL;
Index: ofa_kernel-1.5.1/drivers/infiniband/core/ucma.c
===================================================================
--- ofa_kernel-1.5.1.orig/drivers/infiniband/core/ucma.c
+++ ofa_kernel-1.5.1/drivers/infiniband/core/ucma.c
@@ -584,13 +584,23 @@ static void ucma_copy_iboe_route(struct
 				   struct rdma_route *route)
 {
 	struct rdma_dev_addr *dev_addr;
+	struct net_device *dev;
+	u16 vid = 0;
 
 	resp->num_paths = route->num_paths;
 	switch (route->num_paths) {
 	case 0:
 		dev_addr = &route->addr.dev_addr;
-		iboe_mac_to_ll((union ib_gid *) &resp->ib_route[0].dgid,
-				 dev_addr->dst_dev_addr);
+		dev = dev_get_by_index(&init_net, dev_addr->bound_dev_if);
+		if (dev) {
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+			vid = vlan_dev_vlan_id(dev);
+#endif
+			dev_put(dev);
+		}
+
+		iboe_mac_vlan_to_ll((union ib_gid *) &resp->ib_route[0].dgid,
+				    dev_addr->dst_dev_addr, vid);
 		iboe_addr_get_sgid(dev_addr,
 				 (union ib_gid *) &resp->ib_route[0].sgid);
 		resp->ib_route[0].pkey = cpu_to_be16(0xffff);
Index: ofa_kernel-1.5.1/drivers/infiniband/core/ud_header.c
===================================================================
--- ofa_kernel-1.5.1.orig/drivers/infiniband/core/ud_header.c
+++ ofa_kernel-1.5.1/drivers/infiniband/core/ud_header.c
@@ -33,6 +33,7 @@
 
 #include <linux/errno.h>
 #include <linux/string.h>
+#include <linux/if_ether.h>
 
 #include <rdma/ib_pack.h>
 
@@ -103,6 +104,17 @@ static const struct ib_field eth_table[]
 	  .size_bits    = 16 }
 };
 
+static const struct ib_field vlan_table[]  = {
+	{ STRUCT_FIELD(vlan, tag),
+	  .offset_words = 0,
+	  .offset_bits  = 0,
+	  .size_bits    = 16 },
+	{ STRUCT_FIELD(vlan, type),
+	  .offset_words = 0,
+	  .offset_bits  = 16,
+	  .size_bits    = 16 }
+};
+
 static const struct ib_field grh_table[]  = {
 	{ STRUCT_FIELD(grh, ip_version),
 	  .offset_words = 0,
@@ -205,6 +217,7 @@ static const struct ib_field deth_table[
  * @payload_bytes:Length of packet payload
  * @lrh_present: specify if LRH is present
  * @eth_present: specify if Eth header is present
+ * @vlan_present: packet is tagged vlan
  * @grh_present:GRH flag (if non-zero, GRH will be included)
  * @immediate_present: specify if immediate data is present
  * @header:Structure to initialize
@@ -212,6 +225,7 @@ static const struct ib_field deth_table[
 void ib_ud_header_init(int     		    payload_bytes,
 		       int		    lrh_present,
 		       int		    eth_present,
+		       int		    vlan_present,
 		       int    		    grh_present,
 		       int		    immediate_present,
 		       struct ib_ud_header *header)
@@ -227,8 +241,15 @@ void ib_ud_header_init(int     		    pay
 		packet_length = IB_LRH_BYTES;
 	}
 
-	if (eth_present)
+	if (eth_present) {
+		if (vlan_present) {
+			header->eth.type = cpu_to_be16(ETH_P_8021Q);
+			packet_length += IB_VLAN_BYTES;
+
+		}
 		packet_length += IB_ETH_BYTES;
+	}
+
 	packet_length += IB_BTH_BYTES + IB_DETH_BYTES + payload_bytes +
 		4       + /* ICRC     */
 		3;        /* round up */
@@ -257,6 +278,7 @@ void ib_ud_header_init(int     		    pay
 
 	header->lrh_present = lrh_present;
 	header->eth_present = eth_present;
+	header->vlan_present = vlan_present;
 	header->grh_present = grh_present;
 	header->immediate_present = immediate_present;
 }
@@ -317,6 +339,12 @@ int ib_ud_header_pack(struct ib_ud_heade
 	}
 
 
+	if (header->vlan_present) {
+		ib_pack(vlan_table, ARRAY_SIZE(vlan_table),
+			&header->vlan, buf + len);
+		len += IB_VLAN_BYTES;
+	}
+
 	if (header->grh_present) {
 		ib_pack(grh_table, ARRAY_SIZE(grh_table),
 			&header->grh, buf + len);
Index: ofa_kernel-1.5.1/drivers/infiniband/core/uverbs_cmd.c
===================================================================
--- ofa_kernel-1.5.1.orig/drivers/infiniband/core/uverbs_cmd.c
+++ ofa_kernel-1.5.1/drivers/infiniband/core/uverbs_cmd.c
@@ -1875,7 +1875,7 @@ ssize_t ib_uverbs_get_eth_l2_addr(struct
 		return -EINVAL;
 
 	ret = ib_get_eth_l2_addr(pd->device, cmd.port, (union ib_gid *)cmd.gid,
-				 cmd.sgid_idx, resp.mac);
+				 cmd.sgid_idx, resp.mac, &resp.vlan_id);
 	put_pd_read(pd);
 	if (!ret) {
 		if (copy_to_user((void __user *) (unsigned long) cmd.response,
Index: ofa_kernel-1.5.1/drivers/infiniband/core/verbs.c
===================================================================
--- ofa_kernel-1.5.1.orig/drivers/infiniband/core/verbs.c
+++ ofa_kernel-1.5.1/drivers/infiniband/core/verbs.c
@@ -1047,11 +1047,11 @@ struct ib_xrcd *ib_alloc_xrcd(struct ib_
 EXPORT_SYMBOL(ib_alloc_xrcd);
 
 int ib_get_eth_l2_addr(struct ib_device *device, u8 port, union ib_gid *gid,
-		       int sgid_idx, u8 *mac)
+		       int sgid_idx, u8 *mac, __u16 *vlan_id)
 {
 	if (!device->get_eth_l2_addr)
 		return -ENOSYS;
 
-	return device->get_eth_l2_addr(device, port, gid, sgid_idx, mac);
+	return device->get_eth_l2_addr(device, port, gid, sgid_idx, mac, vlan_id);
 }
 EXPORT_SYMBOL(ib_get_eth_l2_addr);
Index: ofa_kernel-1.5.1/include/rdma/ib_addr.h
===================================================================
--- ofa_kernel-1.5.1.orig/include/rdma/ib_addr.h
+++ ofa_kernel-1.5.1/include/rdma/ib_addr.h
@@ -42,6 +42,7 @@
 #include <rdma/ib_verbs.h>
 #include <rdma/ib_pack.h>
 #include <linux/ethtool.h>
+#include <linux/if_vlan.h>
 
 struct rdma_addr_client {
 	atomic_t refcount;
@@ -130,12 +131,18 @@ static inline int rdma_addr_gid_offset(s
 	return dev_addr->dev_type == ARPHRD_INFINIBAND ? 4 : 0;
 }
 
-static inline void iboe_mac_to_ll(union ib_gid *gid, u8 *mac)
+static inline void iboe_mac_vlan_to_ll(union ib_gid *gid, u8 *mac, u16 vid)
 {
 	memset(gid->raw, 0, 16);
 	*((u32 *)gid->raw) = cpu_to_be32(0xfe800000);
-	gid->raw[12] = 0xfe;
-	gid->raw[11] = 0xff;
+	if (vid) {
+		gid->raw[12] = vid & 0xff;
+		gid->raw[11] = vid >> 8;
+	} else {
+		gid->raw[12] = 0xfe;
+		gid->raw[11] = 0xff;
+	}
+
 	memcpy(gid->raw + 13, mac + 3, 3);
 	memcpy(gid->raw + 8, mac, 3);
 	gid->raw[8] ^= 2;
@@ -144,7 +151,18 @@ static inline void iboe_mac_to_ll(union
 static inline void iboe_addr_get_sgid(struct rdma_dev_addr *dev_addr,
 					union ib_gid *gid)
 {
-	iboe_mac_to_ll(gid, dev_addr->src_dev_addr);
+	struct net_device *dev;
+	u16 vid = 0;
+
+	dev = dev_get_by_index(&init_net, dev_addr->bound_dev_if);
+	if (dev) {
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+		vid = vlan_dev_vlan_id(dev);
+#endif
+		dev_put(dev);
+	}
+
+	iboe_mac_vlan_to_ll(gid, dev_addr->src_dev_addr, vid);
 }
 
 static inline void rdma_addr_get_sgid(struct rdma_dev_addr *dev_addr, union ib_gid *gid)
@@ -244,4 +262,13 @@ static inline void rdma_get_mcast_mac(st
 	for (i = 2; i < 6; ++i)
 		mac[i] = addr->s6_addr[i + 10];
 }
+
+static inline u16 rdma_get_vlan_id(union ib_gid *dgid)
+{
+	u16 vid;
+
+	vid = dgid->raw[11] << 8 | dgid->raw[12];
+	return vid == 0xfffe ? 0 : vid  & 0xfff;
+}
+
 #endif /* IB_ADDR_H */
Index: ofa_kernel-1.5.1/include/rdma/ib_pack.h
===================================================================
--- ofa_kernel-1.5.1.orig/include/rdma/ib_pack.h
+++ ofa_kernel-1.5.1/include/rdma/ib_pack.h
@@ -38,6 +38,7 @@
 enum {
 	IB_LRH_BYTES  = 8,
 	IB_ETH_BYTES  = 14,
+	IB_VLAN_BYTES = 4,
 	IB_GRH_BYTES  = 40,
 	IB_BTH_BYTES  = 12,
 	IB_DETH_BYTES = 8
@@ -219,11 +220,18 @@ struct ib_unpacked_eth {
 	__be16	type;
 };
 
+struct ib_unpacked_vlan {
+	__be16  tag;
+	__be16  type;
+};
+
 struct ib_ud_header {
 	int                     lrh_present;
 	struct ib_unpacked_lrh  lrh;
 	int                     eth_present;
 	struct ib_unpacked_eth  eth;
+	int                     vlan_present;
+	struct ib_unpacked_vlan vlan;
 	int                     grh_present;
 	struct ib_unpacked_grh  grh;
 	struct ib_unpacked_bth  bth;
@@ -245,6 +253,7 @@ void ib_unpack(const struct ib_field
 void ib_ud_header_init(int     		    payload_bytes,
 		       int		    lrh_present,
 		       int		    eth_present,
+		       int		    vlan_present,
 		       int    		    grh_present,
 		       int		    immediate_present,
 		       struct ib_ud_header *header);
Index: ofa_kernel-1.5.1/include/rdma/ib_verbs.h
===================================================================
--- ofa_kernel-1.5.1.orig/include/rdma/ib_verbs.h
+++ ofa_kernel-1.5.1/include/rdma/ib_verbs.h
@@ -1210,7 +1210,7 @@ struct ib_device {
 						       u32 qp_num);
 	int			   (*get_eth_l2_addr)(struct ib_device *device, u8 port,
 						      union ib_gid *dgid, int sgid_idx,
-						      u8 *mac);
+						      u8 *mac, u16 *vlan_id);
 
 	struct ib_dma_mapping_ops   *dma_ops;
 
@@ -2166,8 +2166,9 @@ struct ib_xrcd *ib_alloc_xrcd(struct ib_
   * @gid: gid to be resolved into mac
   * @sgid_idx: index to port's gid table for the corresponding address vector
   * @mac: mac of the port bearing this gid
+  * @vlan_id: vlan to be used to reach this gid
   */
 int ib_get_eth_l2_addr(struct ib_device *device, u8 port, union ib_gid *gid,
-		       int sgid_idx, u8 *mac);
+		       int sgid_idx, u8 *mac, __u16 *vlan_id);
 
 #endif /* IB_VERBS_H */
Index: ofa_kernel-1.5.1/include/rdma/ib_user_verbs.h
===================================================================
--- ofa_kernel-1.5.1.orig/include/rdma/ib_user_verbs.h
+++ ofa_kernel-1.5.1/include/rdma/ib_user_verbs.h
@@ -642,7 +642,7 @@ struct ib_uverbs_get_eth_l2_addr {
 
 struct ib_uverbs_get_eth_l2_addr_resp {
 	__u8	mac[6];
-	__u16	reserved;
+	__u16	vlan_id;
 };
 
 struct ib_uverbs_attach_mcast {
